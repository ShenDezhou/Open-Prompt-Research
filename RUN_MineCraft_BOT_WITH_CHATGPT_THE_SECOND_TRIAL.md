# ChatGPT playing Minecraft.

新版ChatGPT(0613)版是更强的代码生成LLM，使用ChatGPT的价格，在代码驱动的Minecraft世界探索上可以达到原GPT-4模型的效果。

前几日用ChatGPT(0613版和旧版)均无法正常驱动MineCraft-BOT。遇到的错误有：
* TypeError: Cannot read properties of undefined (reading 'blocksByName')
* TypeError: bot.inventory.findItem is not a function
* AssertionError [ERR_ASSERTION]: No valid type given
* TypeError: Cannot read properties of undefined (reading 'oak_log')

根据`TypeError: Cannot read properties of undefined (reading 'oak_log')`错误，使用进行了单步调试，发现原控制原语中对`mcData`的使用有未赋值直接使用的问题，即报undefined错误。

```shell
curl -XPOST 127.0.0.1:3000/step -H 'Content-Type: application/json'  -d '{"code": "async function mineWoodLog(bot) {\n  await mineBlock(bot, \"oak_log\", 1)}\n await mineWoodLog(bot);",   "programs":"async function mineBlock(bot, name, count = 1) {\n    // return if name is not string\n    if (typeof name !== \"string\") {\n        throw new Error(`name for mineBlock must be a string`);\n    }\n    if (typeof count !== \"number\") {\n        throw new Error(`count for mineBlock must be a number`);\n    }\n    const mcData = mineData(bot.version);\nconst blockByName = mcData.blocksByName[name];\n    if (!blockByName) {\n        throw new Error(`No block named ${name}`);\n    }\n    const blocks = bot.findBlocks({\n        matching: [blockByName.id],\n        maxDistance: 32,\n        count: 1024,\n    });\n    if (blocks.length === 0) {\n        bot.chat(`No ${name} nearby, please explore first`);\n        _mineBlockFailCount++;\n        if (_mineBlockFailCount > 10) {\n            throw new Error(\n                \"mineBlock failed too many times, make sure you explore before calling mineBlock\"\n            );\n        }\n        return;\n    }\n    const targets = [];\n    for (let i = 0; i < blocks.length; i++) {\n        targets.push(bot.blockAt(blocks[i]));\n    }\n    await bot.collectBlock.collect(targets, {\n        ignoreNoPath: true,\n        count: count,\n    });\n    bot.save(`${name}_mined`);\n}\n"}'
```

因此，对控制原语[control_primitives](control_primitives)中函数进行了调整，增加的对mdData的定义。

修改方式为`const mcData = mineData(bot.version);`。

## 效果

上述step代码，会驱动BOT进行伐木。

Server日志也提示：
```shell
[19:48:53] [Server thread/INFO]: <bot> Failed to pickup item! Skip it!
[19:48:53] [Server thread/INFO]: <bot> Collect finish!
[19:50:16] [Server thread/INFO]: <bot> Collect finish!
[19:50:19] [Server thread/INFO]: <bot> Error: Path was stopped before it could be completed! Thus, the desired goal was not reached.
[19:50:30] [Server thread/INFO]: <bot> Collect finish!
```

## ChatGPT再尝试

结论，第二次基于ChatGPT运行成功，所有LLM、Node和Event日志均存于[execution_log_success](execution_log_success)。

由日志看，经过调整后的控制原语及模版起到了效果，由原来的多次无法生成正确代码（因示例代码不够完善，缺少关键获取mineData数据的语句）。

调整后基于ChatGPT即可运行正确代码，本文测试使用版本为`gpt-3.5-turbo-0613`。不需要调用昂贵的`GPT-4`即可探索MineCraft世界。

### ActionAgent的全部对话

下面JSON所列三部分为`System输入、Human输入，AI/LLM生成`。
```json
[
  "You are a helpful assistant that writes Mineflayer javascript code to complete any Minecraft task specified by me.\n\nHere are some useful programs written with Mineflayer APIs.\n\n/*\nExplore until find an iron_ore, use Vec3(0, -1, 0) because iron ores are usually underground\nawait exploreUntil(bot, new Vec3(0, -1, 0), 60, () => {\n    const iron_ore = bot.findBlock({\n        matching: mcData.blocksByName[\"iron_ore\"].id,\n        maxDistance: 32,\n    });\n    return iron_ore;\n});\n\nExplore until find a pig, use Vec3(1, 0, 1) because pigs are usually on the surface\nlet pig = await exploreUntil(bot, new Vec3(1, 0, 1), 60, () => {\n    const pig = bot.nearestEntity((entity) => {\n        return (\n            entity.name === \"pig\" &&\n            entity.position.distanceTo(bot.entity.position) < 32\n        );\n    });\n    return pig;\n});\n*/\nasync function exploreUntil(bot, direction, maxTime = 60, callback) {\n    /*\n    Implementation of this function is omitted.\n    direction: Vec3, can only contain value of -1, 0 or 1\n    maxTime: number, the max time for exploration\n    callback: function, early stop condition, will be called each second, exploration will stop if return value is not null\n\n    Return: null if explore timeout, otherwise return the return value of callback\n    */\n}\n\n\n// Mine 3 cobblestone: mineBlock(bot, \"stone\", 3);\nasync function mineBlock(bot, name, count = 1) {\n    const mcData = mineData(bot.version);\n    const blocks = bot.findBlocks({\n        matching: (block) => {\n            return block.name === name;\n        },\n        maxDistance: 32,\n        count: count,\n    });\n    const targets = [];\n    for (let i = 0; i < Math.min(blocks.length, count); i++) {\n        targets.push(bot.blockAt(blocks[i]));\n    }\n    await bot.collectBlock.collect(targets, { ignoreNoPath: true });\n}\n\n\n// Craft 8 oak_planks from 2 oak_log (do the recipe 2 times): craftItem(bot, \"oak_planks\", 2);\n// You must place a crafting table before calling this function\nasync function craftItem(bot, name, count = 1) {\n    const mcData = mineData(bot.version);\n    const item = mcData.itemsByName[name];\n    const craftingTable = bot.findBlock({\n        matching: mcData.blocksByName.crafting_table.id,\n        maxDistance: 32,\n    });\n    await bot.pathfinder.goto(\n        new GoalLookAtBlock(craftingTable.position, bot.world)\n    );\n    const recipe = bot.recipesFor(item.id, null, 1, craftingTable)[0];\n    await bot.craft(recipe, count, craftingTable);\n}\n\n\n// Place a crafting_table near the player, Vec3(1, 0, 0) is just an example, you shouldn't always use that: placeItem(bot, \"crafting_table\", bot.entity.position.offset(1, 0, 0));\nasync function placeItem(bot, name, position) {\n    const mcData = mineData(bot.version);\n    const item = bot.inventory.findInventoryItem(mcData.itemsByName[name].id);\n    // find a reference block\n    const faceVectors = [\n        new Vec3(0, 1, 0),\n        new Vec3(0, -1, 0),\n        new Vec3(1, 0, 0),\n        new Vec3(-1, 0, 0),\n        new Vec3(0, 0, 1),\n        new Vec3(0, 0, -1),\n    ];\n    let referenceBlock = null;\n    let faceVector = null;\n    for (const vector of faceVectors) {\n        const block = bot.blockAt(position.minus(vector));\n        if (block?.name !== \"air\") {\n            referenceBlock = block;\n            faceVector = vector;\n            break;\n        }\n    }\n    // You must first go to the block position you want to place\n    await bot.pathfinder.goto(new GoalPlaceBlock(position, bot.world, {}));\n    // You must equip the item right before calling placeBlock\n    await bot.equip(item, \"hand\");\n    await bot.placeBlock(referenceBlock, faceVector);\n}\n\n\n// Smelt 1 raw_iron into 1 iron_ingot using 1 oak_planks as fuel: smeltItem(bot, \"raw_iron\", \"oak_planks\");\n// You must place a furnace before calling this function\nasync function smeltItem(bot, itemName, fuelName, count = 1) {\n    const mcData = mineData(bot.version);\n    const item = mcData.itemsByName[itemName];\n    const fuel = mcData.itemsByName[fuelName];\n    const furnaceBlock = bot.findBlock({\n        matching: mcData.blocksByName.furnace.id,\n        maxDistance: 32,\n    });\n    await bot.pathfinder.goto(\n        new GoalLookAtBlock(furnaceBlock.position, bot.world)\n    );\n    const furnace = await bot.openFurnace(furnaceBlock);\n    for (let i = 0; i < count; i++) {\n        await furnace.putFuel(fuel.id, null, 1);\n        await furnace.putInput(item.id, null, 1);\n        // Wait 12 seconds for the furnace to smelt the item\n        await bot.waitForTicks(12 * 20);\n        await furnace.takeOutput();\n    }\n    await furnace.close();\n}\n\n\n// Kill a pig and collect the dropped item: killMob(bot, \"pig\", 300);\nasync function killMob(bot, mobName, timeout = 300) {\n    const entity = bot.nearestEntity(\n        (entity) =>\n            entity.name === mobName &&\n            entity.position.distanceTo(bot.entity.position) < 32\n    );\n    await bot.pvp.attack(entity);\n    await bot.pathfinder.goto(\n        new GoalBlock(entity.position.x, entity.position.y, entity.position.z)\n    );\n}\n\n\n// Get a torch from chest at (30, 65, 100): getItemFromChest(bot, new Vec3(30, 65, 100), {\"torch\": 1});\n// This function will work no matter how far the bot is from the chest.\nasync function getItemFromChest(bot, chestPosition, itemsToGet) {\n    const mcData = mineData(bot.version);\n    await moveToChest(bot, chestPosition);\n    const chestBlock = bot.blockAt(chestPosition);\n    const chest = await bot.openContainer(chestBlock);\n    for (const name in itemsToGet) {\n        const itemByName = mcData.itemsByName[name];\n        const item = chest.findContainerItem(itemByName.id);\n        await chest.withdraw(item.type, null, itemsToGet[name]);\n    }\n    await closeChest(bot, chestBlock);\n}\n// Deposit a torch into chest at (30, 65, 100): depositItemIntoChest(bot, new Vec3(30, 65, 100), {\"torch\": 1});\n// This function will work no matter how far the bot is from the chest.\nasync function depositItemIntoChest(bot, chestPosition, itemsToDeposit) {\n    await moveToChest(bot, chestPosition);\n    const chestBlock = bot.blockAt(chestPosition);\n    const chest = await bot.openContainer(chestBlock);\n    for (const name in itemsToDeposit) {\n        const itemByName = mcData.itemsByName[name];\n        const item = bot.inventory.findInventoryItem(itemByName.id);\n        await chest.deposit(item.type, null, itemsToDeposit[name]);\n    }\n    await closeChest(bot, chestBlock);\n}\n// Check the items inside the chest at (30, 65, 100): checkItemInsideChest(bot, new Vec3(30, 65, 100));\n// You only need to call this function once without any action to finish task of checking items inside the chest.\nasync function checkItemInsideChest(bot, chestPosition) {\n    await moveToChest(bot, chestPosition);\n    const chestBlock = bot.blockAt(chestPosition);\n    await bot.openContainer(chestBlock);\n    // You must close the chest after opening it if you are asked to open a chest\n    await closeChest(bot, chestBlock);\n}\n\n\nawait bot.pathfinder.goto(goal); // A very useful function. This function may change your main-hand equipment.\n// Following are some Goals you can use:\nnew GoalNear(x, y, z, range); // Move the bot to a block within the specified range of the specified block. `x`, `y`, `z`, and `range` are `number`\nnew GoalXZ(x, z); // Useful for long-range goals that don't have a specific Y level. `x` and `z` are `number`\nnew GoalGetToBlock(x, y, z); // Not get into the block, but get directly adjacent to it. Useful for fishing, farming, filling bucket, and beds. `x`, `y`, and `z` are `number`\nnew GoalFollow(entity, range); // Follow the specified entity within the specified range. `entity` is `Entity`, `range` is `number`\nnew GoalPlaceBlock(position, bot.world, {}); // Position the bot in order to place a block. `position` is `Vec3`\nnew GoalLookAtBlock(position, bot.world, {}); // Path into a position where a blockface of the block at position is visible. `position` is `Vec3`\n\n// These are other Mineflayer functions you can use:\nbot.isABed(bedBlock); // Return true if `bedBlock` is a bed\nbot.blockAt(position); // Return the block at `position`. `position` is `Vec3`\n\n// These are other Mineflayer async functions you can use:\nawait bot.equip(item, destination); // Equip the item in the specified destination. `item` is `Item`, `destination` can only be \"hand\", \"head\", \"torso\", \"legs\", \"feet\", \"off-hand\"\nawait bot.consume(); // Consume the item in the bot's hand. You must equip the item to consume first. Useful for eating food, drinking potions, etc.\nawait bot.fish(); // Let bot fish. Before calling this function, you must first get to a water block and then equip a fishing rod. The bot will automatically stop fishing when it catches a fish\nawait bot.sleep(bedBlock); // Sleep until sunrise. You must get to a bed block first\nawait bot.activateBlock(block); // This is the same as right-clicking a block in the game. Useful for buttons, doors, etc. You must get to the block first\nawait bot.lookAt(position); // Look at the specified position. You must go near the position before you look at it. To fill bucket with water, you must lookAt first. `position` is `Vec3`\nawait bot.activateItem(); // This is the same as right-clicking to use the item in the bot's hand. Useful for using buckets, etc. You must equip the item to activate first\nawait bot.useOn(entity); // This is the same as right-clicking an entity in the game. Useful for shearing sheep, equipping harnesses, etc. You must get to the entity first\n\n\n\nAt each round of conversation, I will give you\nCode from the last round: ...\nExecution error: ...\nChat log: ...\nBiome: ...\nTime: ...\nNearby blocks: ...\nNearby entities (nearest to farthest):\nHealth: ...\nHunger: ...\nPosition: ...\nEquipment: ...\nInventory (xx/36): ...\nChests: ...\nTask: ...\nContext: ...\nCritique: ...\n\nYou should then respond to me with\nExplain (if applicable): Are there any steps missing in your plan? Why does the code not complete the task? What does the chat log and execution error imply?\nPlan: How to complete the task step by step. You should pay attention to Inventory since it tells what you have. The task completeness check is also based on your final inventory.\nCode:\n    1) Write an async function taking the bot as the only argument.\n    2) Reuse the above useful programs as much as possible.\n        - Use `mineBlock(bot, name, count)` to collect blocks. Do not use `bot.dig` directly.\n        - Use `craftItem(bot, name, count)` to craft items. Do not use `bot.craft` or `bot.recipesFor` directly.\n        - Use `smeltItem(bot, name count)` to smelt items. Do not use `bot.openFurnace` directly.\n        - Use `placeItem(bot, name, position)` to place blocks. Do not use `bot.placeBlock` directly.\n        - Use `killMob(bot, name, timeout)` to kill mobs. Do not use `bot.attack` directly.\n    3) Your function will be reused for building more complex functions. Therefore, you should make it generic and reusable. You should not make strong assumption about the inventory (as it may be changed at a later time), and therefore you should always check whether you have the required items before using them. If not, you should first collect the required items and reuse the above useful programs.\n    4) Functions in the \"Code from the last round\" section will not be saved or executed. Do not reuse functions listed there.\n    5) Anything defined outside a function will be ignored, define all your variables inside your functions.\n    6) Call `bot.chat` to show the intermediate progress.\n    7) Use `exploreUntil(bot, direction, maxDistance, callback)` when you cannot find something. You should frequently call this before mining blocks or killing mobs. You should select a direction at random every time instead of constantly using (1, 0, 1).\n    8) `maxDistance` should always be 32 for `bot.findBlocks` and `bot.findBlock`. Do not cheat.\n    9) Do not write infinite loops or recursive functions.\n    10) Do not use `bot.on` or `bot.once` to register event listeners. You definitely do not need them.\n    11) Name your function in a meaningful way (can infer the task from the name).\n\nYou should only respond in the format as described below:\nRESPONSE FORMAT:\nExplain: ...\nPlan:\n1) ...\n2) ...\n3) ...\n...\nCode:\n```javascript\n// helper functions (only if needed, try to avoid them)\n...\n// main function after the helper functions\nasync function yourMainFunctionName(bot) {\n  // ...\n}\n```\n",
  "Code from the last round: No code in the first round\n\nExecution error: No error\n\nChat log: None\n\nBiome: savanna\n\nTime: sunrise\n\nNearby blocks: stone, dirt, copper_ore, grass_block, grass, coal_ore, tall_grass\n\nNearby entities (nearest to farthest): sheep\n\nHealth: 20.0/20\n\nHunger: 20.0/20\n\nPosition: x=664.5, y=69.0, z=434.5\n\nEquipment: [None, None, None, None, None, None]\n\nInventory (0/36): Empty\n\nChests: None\n\nTask: Mine 1 wood log\n\nContext: You can mine one of oak, birch, spruce, jungle, acacia, dark oak, or mangrove logs.\n\nCritique: None\n\n",
  "Explain: The task is to mine 1 wood log, which can be any type of log such as oak, birch, spruce, jungle, acacia, dark oak, or mangrove.\n\nPlan:\n1) Check if the bot has any wood logs in its inventory.\n2) If the bot does not have any wood logs, explore the area until it finds a tree.\n3) Once a tree is found, mine one wood log using the `mineBlock` function.\n4) Repeat steps 1-3 until the bot has mined 1 wood log.\n\nCode:\n```javascript\nasync function mineWoodLog(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n\n  // Check if the bot has any wood logs in its inventory\n  const woodLog = bot.inventory.items().find(item => mcData.blocksByName[item.name]?.name.endsWith('_log'));\n  if (woodLog) {\n    bot.chat(`I already have a wood log in my inventory.`);\n    return;\n  }\n\n  // Explore until a tree is found\n  const tree = await exploreUntil(bot, new Vec3(1, 0, 1), 60, () => {\n    const log = bot.findBlock({\n      matching: block => mcData.blocksByName[block.name]?.name.endsWith('_log'),\n      maxDistance: 32,\n    });\n    return log;\n  });\n\n  if (!tree) {\n    bot.chat(`I couldn't find any trees nearby.`);\n    return;\n  }\n\n  // Mine one wood log\n  await mineBlock(bot, mcData.blocksByName[tree.name].name, 1);\n  bot.chat(`I have mined one wood log.`);\n}\n\nmineWoodLog(bot);\n```\n"
]
```

由运行结果可见，ChatGPT驱动的ActionAgent成功写出第一个任务的代码。

### CriticAgent的对话

下面JSON所列三部分为`System输入、Human输入，AI/LLM生成`。
```json
[
  "You are an assistant that assesses my progress of playing Minecraft and provides useful guidance.\n\nYou are required to evaluate if I have met the task requirements. Exceeding the task requirements is also considered a success while failing to meet them requires you to provide critique to help me improve.\n\nI will give you the following information:\n\nBiome: The biome after the task execution.\nTime: The current time.\nNearby blocks: The surrounding blocks. These blocks are not collected yet. However, this is useful for some placing or planting tasks.\nHealth: My current health.\nHunger: My current hunger level. For eating task, if my hunger level is 20.0, then I successfully ate the food.\nPosition: My current position.\nEquipment: My final equipment. For crafting tasks, I sometimes equip the crafted item.\nInventory (xx/36): My final inventory. For mining and smelting tasks, you only need to check inventory.\nChests: If the task requires me to place items in a chest, you can find chest information here.\nTask: The objective I need to accomplish.\nContext: The context of the task.\n\nYou should only respond in JSON format as described below:\n{\n    \"reasoning\": \"reasoning\",\n    \"success\": boolean,\n    \"critique\": \"critique\",\n}\nEnsure the response can be parsed by Python `json.loads`, e.g.: no trailing commas, no single quotes, etc.\n\nHere are some examples:\nINPUT:\nInventory (2/36): {'oak_log':2, 'spruce_log':2}\n\nTask: Mine 3 wood logs\n\nRESPONSE:\n{\n    \"reasoning\": \"You need to mine 3 wood logs. You have 2 oak logs and 2 spruce logs, which add up to 4 wood logs.\",\n    \"success\": true,\n    \"critique\": \"\"\n}\n\nINPUT:\nInventory (3/36): {'crafting_table': 1, 'spruce_planks': 6, 'stick': 4}\n\nTask: Craft a wooden pickaxe\n\nRESPONSE:\n{\n    \"reasoning\": \"You have enough materials to craft a wooden pickaxe, but you didn't craft it.\",\n    \"success\": false,\n    \"critique\": \"Craft a wooden pickaxe with a crafting table using 3 spruce planks and 2 sticks.\"\n}\n\nINPUT:\nInventory (2/36): {'raw_iron': 5, 'stone_pickaxe': 1}\n\nTask: Mine 5 iron_ore\n\nRESPONSE:\n{\n    \"reasoning\": \"Mining iron_ore in Minecraft will get raw_iron. You have 5 raw_iron in your inventory.\",\n    \"success\": true,\n    \"critique\": \"\"\n}\n\nINPUT:\nBiome: plains\n\nNearby blocks: stone, dirt, grass_block, grass, farmland, wheat\n\nInventory (26/36): ...\n\nTask:  Plant 1 wheat seed.\n\nRESPONSE:\n{\n    \"reasoning\": \"For planting tasks, inventory information is useless. In nearby blocks, there is farmland and wheat, which means you succeed to plant the wheat seed.\",\n    \"success\": true,\n    \"critique\": \"\"\n}\n\nINPUT:\nInventory (11/36): {... ,'rotten_flesh': 1}\n\nTask: Kill 1 zombie\n\nContext: ...\n\nRESPONSE\n{\n    \"reasoning\": \"You have rotten flesh in your inventory, which means you successfully killed one zombie.\",\n    \"success\": true,\n    \"critique\": \"\"\n}\n\nINPUT:\nHunger: 20.0/20.0\n\nInventory (11/36): ...\n\nTask: Eat 1 ...\n\nContext: ...\n\nRESPONSE\n{\n    \"reasoning\": \"For all eating task, if the player's hunger is 20.0, then the player successfully ate the food.\",\n    \"success\": true,\n    \"critique\": \"\"\n}\n\nINPUT:\nNearby blocks: chest\n\nInventory (28/36): {'rail': 1, 'coal': 2, 'oak_planks': 13, 'copper_block': 1, 'diorite': 7, 'cooked_beef': 4, 'granite': 22, 'cobbled_deepslate': 23, 'feather': 4, 'leather': 2, 'cooked_chicken': 3, 'white_wool': 2, 'stick': 3, 'black_wool': 1, 'stone_sword': 2, 'stone_hoe': 1, 'stone_axe': 2, 'stone_shovel': 2, 'cooked_mutton': 4, 'cobblestone_wall': 18, 'crafting_table': 1, 'furnace': 1, 'iron_pickaxe': 1, 'stone_pickaxe': 1, 'raw_copper': 12}\n\nChests:\n(81, 131, 16): {'andesite': 2, 'dirt': 2, 'cobblestone': 75, 'wooden_pickaxe': 1, 'wooden_sword': 1}\n\nTask: Deposit useless items into the chest at (81, 131, 16)\n\nContext: ...\n\nRESPONSE\n{\n    \"reasoning\": \"You have 28 items in your inventory after depositing, which is more than 20. You need to deposit more items from your inventory to the chest.\",\n    \"success\": false,\n    \"critique\": \"Deposit more useless items such as copper_block, diorite, granite, cobbled_deepslate, feather, and leather to meet the requirement of having only 20 occupied slots in your inventory.\"\n}",
  "Biome: savanna\n\nTime: day\n\nNearby blocks: dirt, grass_block, grass, coal_ore, tall_grass, stone, acacia_log\n\nHealth: 20.0/20\n\nHunger: 20.0/20\n\nPosition: x=672.5, y=69.0, z=432.5\n\nEquipment: [None, None, None, None, 'acacia_log', None]\n\nInventory (1/36): {'acacia_log': 1}\n\nChests: None\n\nTask: Mine 1 wood log\n\nContext: You can mine one of oak, birch, spruce, jungle, acacia, dark oak, or mangrove logs.\n\n",
  "{\n    \"reasoning\": \"You need to mine 1 wood log. You have 1 acacia log, which is a wood log.\",\n    \"success\": true,\n    \"critique\": \"\"\n}"
]
```

由结果可见，ChatGPT驱动的CriticAgent成功预测出BOT的动作完成了任务，给出了任务完成的返回数据。

### Task Event

```json
[["onChat", {"onChat": "Explore success.", "voxels": ["stone", "dirt", "copper_ore", "grass_block", "grass", "coal_ore", "tall_grass"], "status": {"health": 20, "food": 20, "saturation": 5, "oxygen": 20, "position": {"x": 664.5, "y": 69, "z": 434.5}, "velocity": {"x": 0, "y": -0.0784000015258789, "z": 0}, "yaw": 3.141592653589793, "pitch": 0, "onGround": true, "equipment": [null, null, null, null, null, null], "name": "bot", "timeSinceOnGround": 0, "isInWater": false, "isInLava": false, "isCollidedHorizontally": false, "isCollidedVertically": true, "biome": "savanna", "entities": {"sheep": 17.061459395375127}, "timeOfDay": "day", "inventoryUsed": 0, "elapsedTime": 20}, "inventory": {}, "nearbyChests": {}, "blockRecords": ["stone", "dirt", "copper_ore", "grass_block", "grass", "coal_ore", "tall_grass"]}], ["onChat", {"onChat": "Collect finish!", "voxels": ["dirt", "grass_block", "grass", "coal_ore", "tall_grass", "stone", "acacia_log"], "status": {"health": 20, "food": 20, "saturation": 5, "oxygen": 20, "position": {"x": 672.5, "y": 69, "z": 432.49744799368324}, "velocity": {"x": 0, "y": -0.0784000015258789, "z": 0}, "yaw": -1.5734143206725948, "pitch": -0.12042771838760125, "onGround": true, "equipment": [null, null, null, null, "acacia_log", null], "name": "bot", "timeSinceOnGround": 0, "isInWater": false, "isInLava": false, "isCollidedHorizontally": false, "isCollidedVertically": true, "biome": "savanna", "entities": {"sheep": 7.187401093710013}, "timeOfDay": "day", "inventoryUsed": 1, "elapsedTime": 129}, "inventory": {"acacia_log": 1}, "nearbyChests": {}, "blockRecords": ["stone", "dirt", "copper_ore", "grass_block", "grass", "coal_ore", "tall_grass", "acacia_log"]}], ["onSave", {"voxels": ["dirt", "grass_block", "grass", "coal_ore", "tall_grass", "stone", "acacia_log"], "status": {"health": 20, "food": 20, "saturation": 5, "oxygen": 20, "position": {"x": 672.5, "y": 69, "z": 432.49744799368324}, "velocity": {"x": 0, "y": -0.0784000015258789, "z": 0}, "yaw": -1.5734143206725948, "pitch": -0.12042771838760125, "onGround": true, "equipment": [null, null, null, null, "acacia_log", null], "name": "bot", "timeSinceOnGround": 0, "isInWater": false, "isInLava": false, "isCollidedHorizontally": false, "isCollidedVertically": true, "biome": "savanna", "entities": {"sheep": 7.187401093710013}, "timeOfDay": "day", "inventoryUsed": 1, "elapsedTime": 129}, "inventory": {"acacia_log": 1}, "onSave": "acacia_log_mined", "nearbyChests": {}, "blockRecords": ["stone", "dirt", "copper_ore", "grass_block", "grass", "coal_ore", "tall_grass", "acacia_log"]}], ["onChat", {"onChat": "I have mined one wood log.", "voxels": ["dirt", "grass_block", "grass", "coal_ore", "tall_grass", "stone", "acacia_log"], "status": {"health": 20, "food": 20, "saturation": 5, "oxygen": 20, "position": {"x": 672.5, "y": 69, "z": 432.49744799368324}, "velocity": {"x": 0, "y": -0.0784000015258789, "z": 0}, "yaw": -1.5734143206725948, "pitch": -0.12042771838760125, "onGround": true, "equipment": [null, null, null, null, "acacia_log", null], "name": "bot", "timeSinceOnGround": 0, "isInWater": false, "isInLava": false, "isCollidedHorizontally": false, "isCollidedVertically": true, "biome": "savanna", "entities": {"sheep": 7.187401093710013}, "timeOfDay": "day", "inventoryUsed": 1, "elapsedTime": 129}, "inventory": {"acacia_log": 1}, "nearbyChests": {}, "blockRecords": ["stone", "dirt", "copper_ore", "grass_block", "grass", "coal_ore", "tall_grass", "acacia_log"]}], ["observe", {"voxels": ["dirt", "grass_block", "grass", "coal_ore", "tall_grass", "stone", "acacia_log"], "status": {"health": 20, "food": 20, "saturation": 5, "oxygen": 20, "position": {"x": 672.5, "y": 69, "z": 432.49744799368324}, "velocity": {"x": 0, "y": -0.0784000015258789, "z": 0}, "yaw": -1.5734143206725948, "pitch": -0.12042771838760125, "onGround": true, "equipment": [null, null, null, null, "acacia_log", null], "name": "bot", "timeSinceOnGround": 0, "isInWater": false, "isInLava": false, "isCollidedHorizontally": false, "isCollidedVertically": true, "biome": "savanna", "entities": {"sheep": 7.187401093710013}, "timeOfDay": "day", "inventoryUsed": 1, "elapsedTime": 270}, "inventory": {"acacia_log": 1}, "nearbyChests": {}, "blockRecords": ["stone", "dirt", "copper_ore", "grass_block", "grass", "coal_ore", "tall_grass", "acacia_log"]}]]
```

任务成功执行，Event记录器成功记录BOT所说`Explore success.`

### Node日志

由Node日志[20230616_213211.log](execution_log_success%2F20230616_213211.log)可见，未报任何异常。

## 结论

经调整后的代码，在使用LLM生成代码效果更高。值得注意的是，OpenAI在06/14发布了新版ChatGPT，即当前测试的版本。
因此，可以怀疑ChatGPT在升级后代码生成能力显著增强。
也可以推测[control_primitives](control_primitives)与[control_primitives_context](control_primitives_context)
中的控制语句应在逻辑上自洽，否则node在执行代码时，经常会报简单错误，影响BOT运行效率。

## 感谢

本项目在开发过程中用到了[Voyage](voyager.minedojo.org)项目，在此表示感谢。

并且声明，本项目并非原[Voyage](voyager.minedojo.org)项目。





